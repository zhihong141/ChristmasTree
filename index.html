<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree Particles</title>
    <!-- Import Cinzel Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <!-- Import gif.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205; 
            font-family: 'Cinzel', serif;
            user-select: none; 
            -webkit-user-select: none;
            touch-action: none; 
        }
        canvas {
            display: block;
        }
        /* UI Container for easy hiding */
        .ui-layer {
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
            pointer-events: auto;
        }
        .ui-layer.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #instructions {
            position: absolute;
            top: 20px;
            width: 80%;
            left: 10%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 3px;
            font-size: 0.9rem;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            z-index: 5;
            font-weight: 700;
            cursor: text; 
            border-bottom: 1px solid transparent;
            transition: border-color 0.3s;
        }
        #instructions:hover, #instructions:focus {
            border-bottom: 1px solid rgba(255,255,255,0.3);
            outline: none;
        }

        #footer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-family: 'Cinzel', serif;
            font-size: 0.6rem;
            pointer-events: none;
            letter-spacing: 1px;
            text-transform: uppercase;
            z-index: 5;
        }
        #countdown {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
            text-align: right;
            z-index: 5;
        }
        #countdown label {
            display: block;
            font-size: 0.5rem;
            opacity: 0.7;
            font-family: 'Cinzel', serif;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .control-btn {
            position: absolute;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.7rem;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            transition: all 0.3s;
            border-radius: 20px;
            background: rgba(0,0,0,0.2);
            z-index: 10;
            backdrop-filter: blur(2px);
            -webkit-tap-highlight-color: transparent;
            text-align: center;
            min-width: 80px;
            letter-spacing: 1px;
        }
        .control-btn:active, .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: white;
        }
        .control-btn.active {
            background: rgba(255, 255, 255, 0.4);
            color: white;
            border-color: white;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        .control-btn.processing {
            background: rgba(255, 215, 0, 0.3);
            border-color: #ffd700;
            color: #fff;
            cursor: wait;
            animation: pulse-yellow 1s infinite;
        }
        @keyframes pulse-yellow {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        #theme-btn { top: 50px; }
        #music-btn { top: 90px; }
        #blizzard-btn { top: 130px; }
        #gif-btn { top: 170px; }

        @media (max-width: 600px) {
            #instructions {
                top: 20px;
                font-size: 0.8rem;
            }
            #theme-btn { top: 60px; right: 10px; font-size: 0.6rem; padding: 6px 12px; min-width: 60px; }
            #music-btn { top: 95px; right: 10px; font-size: 0.6rem; padding: 6px 12px; min-width: 60px; }
            #blizzard-btn { top: 130px; right: 10px; font-size: 0.6rem; padding: 6px 12px; min-width: 60px; }
            #gif-btn { top: 165px; right: 10px; font-size: 0.6rem; padding: 6px 12px; min-width: 60px; }
            #countdown { right: 10px; bottom: 10px; }
            #footer { left: 10px; bottom: 10px; }
        }
    </style>
</head>
<body>

    <!-- Wrap UI elements for easy hiding -->
    <div id="ui-layer" class="ui-layer">
        <div id="instructions" contenteditable="true">Magic is in the air...</div>
        
        <div id="theme-btn" class="control-btn">Theme: Classic</div>
        <div id="music-btn" class="control-btn">Music: Off</div>
        <div id="blizzard-btn" class="control-btn">Blizzard: Off</div>
        <div id="gif-btn" class="control-btn">Save GIF</div>
        
        <div id="countdown">
            <label>Time to Christmas</label>
            <span id="timer-val">--:--:--:--</span>
        </div>

        <div id="footer">&copy; 2025 Designed by SEVEN.FOUR</div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const instructions = document.getElementById('instructions');
        const themeBtn = document.getElementById('theme-btn');
        const musicBtn = document.getElementById('music-btn');
        const blizzardBtn = document.getElementById('blizzard-btn');
        const gifBtn = document.getElementById('gif-btn');
        const timerVal = document.getElementById('timer-val');
        const uiLayer = document.getElementById('ui-layer');

        let width, height;
        let particles = [];
        let snowParticles = [];
        let fireflies = [];
        let greetingParticles = []; 
        let shootingStars = [];
        let sparklers = [];
        let fireworks = []; 
        let treeScale = 1; 
        let starTopper = null; 
        let beatIntensity = 0; 
        
        let rotationSpeed = 0.005;
        let autoRotate = 0;
        let wind = 0;
        let targetWind = 0;
        let isBlizzard = false;
        let userHasEditedText = false;
        let isChristmasToday = false; 

        let time = 0; 
        
        let treeState = 'assembling'; 
        let lastTreeState = '';
        let stateTimer = 0;
        let holdDuration = 480; 

        const PARTICLE_COUNT = 2200; 
        const GIFT_PARTICLE_COUNT = 300; 
        const TREE_HEIGHT = 500;
        const TREE_WIDTH = 250;
        const FOCAL_LENGTH = 800;
        
        const THEMES = [
            {
                name: 'Classic',
                greens: ['#2e7d32', '#43a047', '#66bb6a', '#a5d6a7', '#1b5e20'],
                giftColors: ['#d32f2f', '#ffa000', '#1976d2'],
                bgGradient: ['#0f2027', '#05101a', '#000000'],
                ornamentStyle: 'dynamic'
            },
            {
                name: 'Frozen',
                greens: ['#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#0288d1'],
                giftColors: ['#ffffff', '#80deea', '#0097a7'],
                bgGradient: ['#1c2e4a', '#101f30', '#000000'],
                ornamentStyle: 'cyan'
            },
            {
                name: 'Midnight',
                greens: ['#7b1fa2', '#8e24aa', '#ab47bc', '#ce93d8', '#4a148c'],
                giftColors: ['#ffd700', '#eeeeee', '#6a1b9a'],
                bgGradient: ['#240b36', '#10051a', '#000000'],
                ornamentStyle: 'gold'
            }
        ];
        let currentThemeIndex = 0;

        // --- GIF SYSTEM ---
        let gif = null;
        let isRecordingGIF = false;
        let gifWorkerBlobURL = null;
        let gifCanvas = document.createElement('canvas'); 
        let gifCtx = gifCanvas.getContext('2d');
        const GIF_WIDTH = 200;  
        const GIF_HEIGHT = 355; 

        fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js')
            .then(r => r.text())
            .then(code => {
                const blob = new Blob([code], {type: 'application/javascript'});
                gifWorkerBlobURL = URL.createObjectURL(blob);
            })
            .catch(e => console.log("Worker load error:", e));

        function startGIFRecording() {
            if (!gifWorkerBlobURL || isRecordingGIF) return;

            isRecordingGIF = true;
            gifBtn.innerText = "Rec...";
            gifBtn.classList.add('processing');
            
            holdDuration = 150; 

            gif = new GIF({
                workers: 2,
                quality: 30, 
                workerScript: gifWorkerBlobURL,
                width: GIF_WIDTH, 
                height: GIF_HEIGHT
            });
            gifCanvas.width = GIF_WIDTH;
            gifCanvas.height = GIF_HEIGHT;

            treeState = 'disassembling';
            stateTimer = 0;
            
            particles.forEach(p => {
                p.resetProperties(); 
                p.y = height + 300;
                p.state = 'idle';
            });
            
            // Force reset greeting particles too
            greetingParticles.forEach(p => {
                p.reset();
                p.y = height + 300;
            });
            
            setTimeout(() => {
                treeState = 'assembling';
                stateTimer = 0;
            }, 100);
        }

        function finishGIFRecording() {
            isRecordingGIF = false;
            gifBtn.innerText = "Encoding...";
            
            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `Christmas_Loop_LowRes_${new Date().getTime()}.gif`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    gifBtn.innerText = "Save GIF";
                    gifBtn.classList.remove('processing');
                    holdDuration = 480; 
                }, 100);
            });

            gif.render();
        }

        // --- MUSIC SYSTEM ---
        const Music = {
            ctx: null,
            isPlaying: false,
            osc: null,
            gain: null,
            timer: null,
            noteIndex: 0,
            melody: [
                {n: 'E4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.5},
                {n: 'E4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.5},
                {n: 'E4', d: 0.25}, {n: 'G4', d: 0.25}, {n: 'C4', d: 0.35}, {n: 'D4', d: 0.15}, {n: 'E4', d: 1.0},
                {n: 'F4', d: 0.25}, {n: 'F4', d: 0.25}, {n: 'F4', d: 0.25}, {n: 'F4', d: 0.25},
                {n: 'F4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.125}, {n: 'E4', d: 0.125},
                {n: 'E4', d: 0.25}, {n: 'D4', d: 0.25}, {n: 'D4', d: 0.25}, {n: 'E4', d: 0.25},
                {n: 'D4', d: 0.5}, {n: 'G4', d: 0.5}
            ],
            freqs: { 'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00 },
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playNote: function(freq, duration) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = freq;
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                const now = this.ctx.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.05); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                osc.start(now);
                osc.stop(now + duration + 0.1);
                beatIntensity = 1.0; 
            },
            loop: function() {
                if (!this.isPlaying) return;
                const note = this.melody[this.noteIndex];
                const freq = this.freqs[note.n];
                const beatDuration = 600; 
                const noteDuration = note.d * beatDuration;
                this.playNote(freq, note.d * 1.5);
                this.noteIndex = (this.noteIndex + 1) % this.melody.length;
                this.timer = setTimeout(() => this.loop(), noteDuration);
            },
            toggle: function() {
                this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = !this.isPlaying;
                if (this.isPlaying) {
                    musicBtn.innerText = "Music: On";
                    this.loop();
                } else {
                    musicBtn.innerText = "Music: Off";
                    clearTimeout(this.timer);
                }
            }
        };

        // --- CLASSES ---

        class GreetingParticle {
            constructor(targetX, targetY) {
                this.targetX = targetX;
                this.targetY = targetY;
                this.reset();
            }
            
            reset() {
                // Similar to main Particle start
                this.x = Math.random() * width;
                this.y = height + Math.random() * 200; 
                this.size = Math.random() * 2.5 + 1.5; // Larger for visibility
                this.opacity = 1;
                this.state = 'idle';
                this.speed = 3 + Math.random() * 2;
                this.drift = Math.random() * Math.PI * 2;
                this.twinkleOffset = Math.random() * 100;
            }

            update() {
                // Sync with global treeState
                if (treeState === 'assembling') {
                    if (this.state !== 'formed') {
                        const distY = this.y - this.targetY;
                        let currentSpeed = this.speed;
                        
                        // Brake logic
                        if (distY < 100 && distY > 0) {
                             currentSpeed = Math.max(0.5, currentSpeed * (distY / 100));
                        }
                        
                        this.y -= currentSpeed;
                        this.x += (this.targetX - this.x) * 0.1; // Lerp to text position
                        
                        if (Math.abs(distY) <= 2 && Math.abs(this.x - this.targetX) < 2) {
                            this.state = 'formed';
                            this.y = this.targetY;
                            this.x = this.targetX;
                        }
                    } else {
                        // Gentle sway when formed - FIXED TO BE STABLE
                        this.x = this.targetX + Math.sin(time * 0.03 + this.targetY) * 1.5;
                        this.y = this.targetY + Math.cos(time * 0.02 + this.targetX) * 1.5;
                    }
                } 
                else if (treeState === 'disassembling') {
                    // Dissipate downwards (fall) - FIXED DIRECTION
                    this.state = 'dissipating';
                    this.y += 2 + Math.random() * 2; 
                    this.x += Math.sin(this.drift + time * 0.05);
                    this.opacity -= 0.02;
                    if(this.opacity < 0) this.opacity = 0;
                }
            }
            
            draw(ctx) {
                if (this.opacity <= 0.01) return;
                
                const alpha = this.opacity * (0.5 + 0.5 * Math.sin(time * 0.1 + this.twinkleOffset));
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#FFD700'; // Pure Gold
                
                // Add pop/glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        class Firefly {
            constructor() {
                this.reset(true); 
            }
            reset(randomStart = false) {
                this.x = Math.random() * width;
                this.y = randomStart ? height - Math.random() * 250 : height + Math.random() * 50;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0.3 + Math.random() * 0.4; 
                this.cycle = Math.random() * Math.PI * 2;
                this.wobble = Math.random() * 0.05;
            }
            update() {
                this.y -= this.speed; 
                this.x += Math.cos(this.angle) * 0.5; 
                this.angle += this.wobble;
                this.cycle += 0.05; 
                if(this.y < height - 300) { 
                    this.reset();
                }
                if(this.x < -50) this.x = width + 50;
                if(this.x > width + 50) this.x = -50;
            }
            draw(ctx) {
                const alpha = 0.2 + 0.6 * Math.sin(this.cycle);
                ctx.globalAlpha = Math.max(0, alpha);
                ctx.fillStyle = '#ffeb3b'; 
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        class StarTopper {
            constructor() { this.reset(); }
            reset() {
                this.x = 0; this.y = TREE_HEIGHT / 2; this.z = 0;
                this.size = 12; this.opacity = 0; this.color = '#fffbe3'; 
                this.twinkleOffset = Math.random() * 100;
            }
            update() {
                if (treeState === 'assembling' || treeState === 'assembled') {
                    if (this.opacity < 1) this.opacity += 0.01;
                } else if (treeState === 'disassembling') {
                    if (this.opacity > 0) this.opacity -= 0.04;
                }
            }
            draw(ctx, centerX, centerY, globalRotation) {
                if (this.opacity <= 0.01) return;
                const beatScale = 1 + beatIntensity * 0.15;
                const scale = (FOCAL_LENGTH / (FOCAL_LENGTH + 0)) * treeScale * beatScale;
                const x2d = centerX; 
                const y2d = centerY - this.y * scale / beatScale; 
                const twinkle = 0.8 + 0.4 * Math.sin(time * 0.15 + this.twinkleOffset);
                
                // Extra glow on Christmas Day
                const extraGlow = isChristmasToday ? 1.5 : 1.0;

                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                
                const spikes = 5;
                const outerRadius = this.size * scale * twinkle * extraGlow;
                const innerRadius = outerRadius / 2;
                
                ctx.save();
                ctx.translate(x2d, y2d);
                ctx.rotate(time * 0.01);
                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const a = (Math.PI / spikes) * i;
                    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                }
                ctx.closePath();
                ctx.shadowBlur = 40 * scale;
                ctx.shadowColor = isChristmasToday ? "rgba(255, 215, 0, 0.9)" : "rgba(255, 255, 200, 0.9)";
                ctx.fill();
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 10 * scale;
                ctx.fill();
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        class Firework {
            constructor(x, y, isClick = false) { this.reset(x, y, isClick); }
            reset(startX, startY, isClick) {
                this.particles = [];
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                if (isClick) {
                    this.state = 'exploding';
                    this.explode(startX, startY);
                } else {
                    this.x = Math.random() * width;
                    this.y = height;
                    this.targetY = height * 0.1 + Math.random() * (height * 0.4);
                    this.speed = 8 + Math.random() * 4;
                    this.state = 'launching';
                }
            }
            update() {
                if (this.state === 'launching') {
                    this.y -= this.speed;
                    this.speed *= 0.98; 
                    if(Math.random() < 0.5) {
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        ctx.fillRect(this.x + (Math.random()-0.5)*2, this.y, 2, 2);
                    }
                    if (this.y <= this.targetY || this.speed < 1) {
                        this.state = 'exploding';
                        this.explode(this.x, this.y);
                    }
                } else if (this.state === 'exploding') {
                    let aliveCount = 0;
                    this.particles.forEach(p => {
                        p.x += p.vx; p.y += p.vy; p.vy += 0.05; 
                        p.life -= 0.02;
                        if(p.life > 0) aliveCount++;
                    });
                    if (aliveCount === 0) this.state = 'dead';
                }
            }
            explode(x, y) {
                const count = 30; 
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    this.particles.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0, color: this.color
                    });
                }
            }
            draw(ctx) {
                if (this.state === 'launching') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x - 1, this.y, 3, 8);
                } else if (this.state === 'exploding') {
                    this.particles.forEach(p => {
                        if (p.life > 0) {
                            ctx.globalAlpha = p.life;
                            ctx.fillStyle = p.color;
                            ctx.fillRect(p.x, p.y, 3, 3);
                        }
                    });
                    ctx.globalAlpha = 1;
                }
            }
        }

        class Sparkler {
            constructor(x, y) {
                this.x = x; this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.decay = Math.random() * 0.03 + 0.01;
                
                // CHRISTMAS EXCLUSIVE: Candy Cane Sparklers
                if (isChristmasToday) {
                    this.color = Math.random() < 0.5 ? '#ff0000' : '#ffffff';
                } else {
                    const colors = ['#ffd700', '#ffffff', '#ff4444'];
                    this.color = colors[Math.floor(Math.random() * colors.length)];
                }
                
                this.gravity = 0.15;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.95; this.vy *= 0.95;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1;
            }
        }

        class ShootingStar {
            constructor() { this.reset(); }
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height * 0.4; 
                this.length = 0;
                this.maxLength = Math.random() * 100 + 50;
                this.speed = Math.random() * 15 + 10;
                this.angle = Math.PI / 4 + (Math.random() * 0.2 - 0.1); 
                this.opacity = 0;
                this.state = 'waiting';
                this.waitTimer = Math.random() * 300 + 100;
            }
            update() {
                if (this.state === 'waiting') {
                    this.waitTimer--;
                    if (this.waitTimer <= 0) {
                        this.state = 'shooting';
                        this.opacity = 1;
                    }
                } else if (this.state === 'shooting') {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.length = Math.min(this.length + this.speed, this.maxLength);
                    this.opacity -= 0.015;
                    if (this.opacity <= 0 || this.x > width || this.y > height) {
                        this.reset();
                    }
                }
            }
            draw(ctx) {
                if (this.state !== 'shooting') return;
                const tailX = this.x - Math.cos(this.angle) * this.length;
                const tailY = this.y - Math.sin(this.angle) * this.length;
                const grad = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
                grad.addColorStop(0, `rgba(255,255,255,${this.opacity})`);
                grad.addColorStop(1, `rgba(255,255,255,0)`);
                ctx.lineWidth = 2;
                ctx.strokeStyle = grad;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(tailX, tailY);
                ctx.stroke();
            }
        }

        class SnowParticle {
            constructor() { this.reset(); }
            reset() {
                this.x = (Math.random() - 0.5) * width;
                this.y = -height/2 - Math.random() * height; 
                this.z = (Math.random() - 0.5) * 800;
                this.size = Math.random() * 2 + 0.5;
                this.speed = Math.random() * 2 + 1;
                this.drift = Math.random() * Math.PI * 2;
                this.vx = 0; this.vy = 0;
                
                // CHRISTMAS MAGIC: 30% chance to be gold on Dec 25
                this.isGold = isChristmasToday && Math.random() < 0.3;
            }
            update() {
                let speedMult = isBlizzard ? 4 : 1; 
                this.vy = this.speed * speedMult;
                let windForce = isBlizzard ? (wind * 2 + 8 + Math.sin(time * 0.1) * 2) : (wind + Math.sin(this.drift) * 0.5);
                this.vx = windForce;
                this.y += this.vy;
                this.x += this.vx;
                this.drift += 0.02;
                if (this.y > height/2 + 200) {
                    this.reset();
                    let spawnOffset = isBlizzard ? -300 : -100;
                    if (this.vx < 0) spawnOffset = 300; 
                    this.x = (Math.random() - 0.5) * width + this.vx * -10; 
                }
            }
            draw(ctx, centerX, centerY) {
                const scale = FOCAL_LENGTH / (FOCAL_LENGTH + this.z);
                const x2d = centerX + this.x * scale;
                const y2d = centerY + this.y * scale;
                ctx.globalAlpha = 0.6 * scale;
                
                // Gold or White snow
                ctx.fillStyle = this.isGold ? '#ffd700' : 'white';
                
                // Add soft glow to golden snow
                if (this.isGold) {
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#ffd700';
                }

                const s = this.size * scale;
                if (isBlizzard) {
                    ctx.lineWidth = s * 0.8;
                    ctx.strokeStyle = this.isGold ? 'rgba(255, 215, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.moveTo(x2d, y2d);
                    ctx.lineTo(x2d - this.vx * scale * 1.5, y2d - this.vy * scale * 1.5);
                    ctx.stroke();
                } else {
                    ctx.fillRect(x2d, y2d, s, s);
                }
                
                ctx.shadowBlur = 0; // Reset
                ctx.globalAlpha = 1;
            }
        }

        class Particle {
            constructor(type) {
                this.type = type; 
                this.twinkleOffset = Math.random() * 100;
                this.resetProperties();
                this.y = height + Math.random() * 200; 
                this.x = (Math.random() - 0.5) * width;
                this.z = (Math.random() - 0.5) * 500;
            }

            resetProperties() {
                const theme = THEMES[currentThemeIndex];
                if (this.type === 'gift') {
                    const giftIndex = Math.floor(Math.random() * theme.giftColors.length);
                    this.color = theme.giftColors[giftIndex];
                    this.size = 2.5;
                    const angleOffset = (giftIndex * (Math.PI * 2 / 3)) + (Math.PI / 6);
                    const radius = 90; 
                    const centerX = Math.cos(angleOffset) * radius;
                    const centerZ = Math.sin(angleOffset) * radius;
                    const boxSize = 50;
                    this.treeTargetX = centerX + (Math.random() - 0.5) * boxSize;
                    this.treeTargetZ = centerZ + (Math.random() - 0.5) * boxSize;
                    this.treeTargetY = -250 + (Math.random() * boxSize); 
                } else {
                    let h = Math.random(); 
                    if (this.type === 'star') {
                        h = 0.99 + Math.random() * 0.01;
                        this.color = '#ffffff';
                        this.size = 2.5 + Math.random() * 2;
                    } else if (this.type === 'ornament') {
                        this.baseHue = Math.random() * 360; 
                        this.size = 3.5; 
                        this.color = null; 
                    } else {
                        this.color = theme.greens[Math.floor(Math.random() * theme.greens.length)];
                        this.size = 1 + Math.random() * 1.5;
                    }
                    const maxR = TREE_WIDTH / 2;
                    const r = (1 - h) * maxR * (0.8 + Math.random() * 0.4); 
                    const angle = Math.random() * Math.PI * 2;
                    this.treeTargetY = (h - 0.5) * TREE_HEIGHT;
                    this.treeTargetX = Math.cos(angle) * r;
                    this.treeTargetZ = Math.sin(angle) * r;
                }
                this.drift = Math.random() * Math.PI * 2;
                this.riseSpeed = 4 + Math.random() * 4;
                this.fallSpeed = 2 + Math.random() * 3;
                this.state = 'idle'; 
                this.opacity = 1;
            }

            refreshColor() {
                const theme = THEMES[currentThemeIndex];
                if (this.type === 'leaf') {
                    this.color = theme.greens[Math.floor(Math.random() * theme.greens.length)];
                } else if (this.type === 'gift') {
                    this.color = theme.giftColors[Math.floor(Math.random() * theme.giftColors.length)];
                }
            }

            update(centerX, centerY, globalRotation) {
                if (treeState === 'assembling') {
                    if (this.state !== 'formed') {
                        const distY = this.y - this.treeTargetY;
                        let currentSpeed = this.riseSpeed;
                        if (distY < 100 && distY > 0) {
                            currentSpeed = Math.max(0.5, currentSpeed * (distY / 100));
                        }
                        this.y -= currentSpeed;
                        this.x += (this.treeTargetX - this.x) * 0.1;
                        this.z += (this.treeTargetZ - this.z) * 0.1;
                        if (Math.abs(distY) <= 1.5 && Math.abs(this.x - this.treeTargetX) < 2) {
                            this.state = 'formed';
                            this.y = this.treeTargetY;
                            this.x = this.treeTargetX;
                            this.z = this.treeTargetZ;
                        }
                    } else {
                        this.drift += 0.05;
                    }
                }
                else if (treeState === 'assembled') {
                    this.drift += 0.05;
                }
                else if (treeState === 'disassembling') {
                    this.state = 'dissipating';
                    this.y += this.fallSpeed; 
                    this.x += Math.sin(this.drift) * 1.0 + wind; 
                    this.z += Math.cos(this.drift) * 1.0;
                    this.drift += 0.05;
                    this.opacity -= 0.015; // Fade out as they fall
                    if (this.opacity < 0) this.opacity = 0;
                }
            }

            draw(ctx, centerX, centerY, globalRotation, alphaMult = 1) {
                let targetRx = (this.state === 'formed') ? this.treeTargetX : this.x;
                let targetRz = (this.state === 'formed') ? this.treeTargetZ : this.z;
                let ry;
                if (this.state !== 'formed') ry = this.y;
                else ry = this.treeTargetY;

                const cos = Math.cos(globalRotation);
                const sin = Math.sin(globalRotation);
                let rx = targetRx * cos - targetRz * sin;
                let rz = targetRx * sin + targetRz * cos;

                const beatScale = 1 + beatIntensity * 0.02;
                const scale = (FOCAL_LENGTH / (FOCAL_LENGTH + rz)) * treeScale * beatScale;
                
                const x2d = centerX + rx * scale;
                const y2d = centerY - ry * scale; 

                let twinkle = 1;
                if (this.type === 'ornament' || this.type === 'star') {
                    twinkle = 0.8 + 0.4 * Math.sin(time * 0.1 + this.twinkleOffset);
                    if (isChristmasToday) twinkle *= 1.5;
                }

                const alpha = Math.min(1, scale * 0.9) * this.opacity * alphaMult;
                ctx.globalAlpha = alpha;
                
                let drawColor = this.color;
                const theme = THEMES[currentThemeIndex];

                if (this.type === 'ornament') {
                    if (theme.ornamentStyle === 'dynamic') {
                        const currentHue = (this.baseHue + time * 0.5) % 360;
                        drawColor = `hsl(${currentHue}, 80%, 60%)`;
                    } else if (theme.ornamentStyle === 'cyan') {
                        drawColor = '#00e5ff';
                    } else if (theme.ornamentStyle === 'gold') {
                        drawColor = '#ffd700';
                    }
                }

                ctx.fillStyle = drawColor;
                let currentSize = this.size * scale;
                if (this.type !== 'leaf' && this.type !== 'gift') {
                     currentSize *= twinkle; 
                }

                if (this.type === 'star') {
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.1, currentSize), 0, Math.PI * 2);
                    ctx.shadowBlur = 30 * scale * twinkle;
                    ctx.shadowColor = `rgba(255, 255, 255, ${0.9 * this.opacity * alphaMult})`;
                    ctx.fill();
                    ctx.shadowBlur = 0; 
                } 
                else if (this.type === 'ornament') {
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.1, currentSize), 0, Math.PI * 2);
                    ctx.fill();
                } 
                else {
                    ctx.fillRect(x2d - currentSize/2, y2d - currentSize/2, currentSize, currentSize);
                }
                ctx.globalAlpha = 1;
            }
        }

        function drawAurora(ctx, width, height, time) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < 3; i++) {
                const gradient = ctx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, `rgba(0, 0, 0, 0)`);
                gradient.addColorStop(0.3, `hsla(${160 + i * 20}, 80%, 30%, 0.1)`);
                gradient.addColorStop(0.5, `hsla(${260 + i * 20}, 70%, 40%, 0.15)`);
                gradient.addColorStop(0.7, `hsla(${160 + i * 20}, 80%, 30%, 0.1)`);
                gradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, height);
                for (let x = 0; x <= width; x += 50) {
                    const y = height * 0.4 + 
                              Math.sin(x * 0.005 + time * 0.02 + i) * 100 + 
                              Math.sin(x * 0.01 - time * 0.01) * 50;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.fill();
            }
            ctx.restore();
        }

        function createGreetingParticles() {
            if (!width || !height) return; 
            const tmpCanvas = document.createElement('canvas');
            const tCtx = tmpCanvas.getContext('2d');
            tmpCanvas.width = width;
            tmpCanvas.height = height;
            
            const fontSize = Math.min(80, width / 10);
            tCtx.font = `bold ${fontSize}px "Cinzel", serif`;
            tCtx.fillStyle = 'white';
            tCtx.textAlign = 'center';
            tCtx.textBaseline = 'middle';
            
            tCtx.fillText('MERRY', width / 2, height * 0.2);
            tCtx.fillText('CHRISTMAS', width / 2, height * 0.35);

            const idata = tCtx.getImageData(0, 0, width, height);
            const data = idata.data;
            
            greetingParticles = [];
            const step = 6; 
            
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    if (data[(y * width + x) * 4 + 3] > 128) {
                        // Pass target x and y
                        greetingParticles.push(new GreetingParticle(x, y));
                    }
                }
            }
        }

        function updateCountdown() {
            const now = new Date();
            const currentYear = now.getFullYear();
            
            if (now.getMonth() === 11 && now.getDate() === 25) {
                timerVal.innerText = "IT'S CHRISTMAS!";
                timerVal.style.color = "#ffd700"; 
                timerVal.style.textShadow = "0 0 10px #ff0000"; 
                return; 
            } else {
                timerVal.style.color = "rgba(255, 255, 255, 0.8)";
                timerVal.style.textShadow = "0 0 5px rgba(255,255,255,0.5)";
            }

            let xmas = new Date(currentYear, 11, 25);
            if (now.getTime() > xmas.getTime() + (1000 * 60 * 60 * 24)) {
                xmas = new Date(currentYear + 1, 11, 25);
            }
            const diff = xmas - now;
            if (diff < 0) return; 

            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            timerVal.innerText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
        }

        function toggleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
            const theme = THEMES[currentThemeIndex];
            themeBtn.innerText = `Theme: ${theme.name}`;
            particles.forEach(p => p.refreshColor());
        }

        function toggleBlizzard() {
            isBlizzard = !isBlizzard;
            blizzardBtn.innerText = isBlizzard ? "Blizzard: ON" : "Blizzard: Off";
            blizzardBtn.classList.toggle('active');
        }

        function launchGrandFinale() {
            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    fireworks.push(new Firework(width*0.2 + Math.random()*width*0.6, height, false));
                }, i * 200);
            }
        }

        let lastTapTime = 0;
        function handleDoubleTap() {
            const now = new Date().getTime();
            if (now - lastTapTime < 300) {
                uiLayer.classList.toggle('hidden');
            }
            lastTapTime = now;
        }

        function init() {
            const now = new Date();
            isChristmasToday = (now.getMonth() === 11 && now.getDate() === 25);

            resize();
            createParticles();
            createSnow();
            createShootingStars();
            createFireflies();
            starTopper = new StarTopper(); 
            
            themeBtn.addEventListener('click', toggleTheme);
            themeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); e.stopPropagation(); toggleTheme();
            }, { passive: false });

            musicBtn.addEventListener('click', () => Music.toggle());
            musicBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); e.stopPropagation(); Music.toggle();
            }, { passive: false });

            blizzardBtn.addEventListener('click', toggleBlizzard);
            blizzardBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); e.stopPropagation(); toggleBlizzard();
            }, { passive: false });

            gifBtn.addEventListener('click', startGIFRecording);
            gifBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); e.stopPropagation(); startGIFRecording();
            }, { passive: false });

            instructions.addEventListener('mousedown', (e) => e.stopPropagation());
            instructions.addEventListener('touchstart', (e) => e.stopPropagation());
            instructions.addEventListener('input', () => { userHasEditedText = true; });

            if(isChristmasToday) {
                for (let i = 0; i < 120; i++) snowParticles.push(new SnowParticle());
                createGreetingParticles();
            }

            animate();
        }

        function createShootingStars() {
            shootingStars = [];
            for(let i=0; i<3; i++) {
                shootingStars.push(new ShootingStar());
            }
        }

        function createSnow() {
            snowParticles = [];
            for (let i = 0; i < 200; i++) {
                snowParticles.push(new SnowParticle());
            }
        }

        function createFireflies() {
            fireflies = [];
            for (let i = 0; i < 30; i++) {
                fireflies.push(new Firefly());
            }
        }

        function createParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let type = 'leaf';
                if (i < 50) type = 'star';
                else if (i < 200) type = 'ornament';
                particles.push(new Particle(type));
            }
            for (let i = 0; i < GIFT_PARTICLE_COUNT; i++) {
                particles.push(new Particle('gift'));
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            treeScale = Math.min(1, Math.max(0.5, width / 350), Math.max(0.5, height / 650));
            
            if(isChristmasToday) createGreetingParticles();
        }

        function animate() {
            // GIF RECORDING LOGIC
            if (isRecordingGIF && gif) {
                if (time % 6 === 0) { 
                    gifCtx.fillStyle = '#000';
                    gifCtx.fillRect(0,0,200,355);
                    gifCtx.drawImage(canvas, 0, 0, width, height, 0, 0, 200, 355);
                    gif.addFrame(gifCtx, {copy: true, delay: 100}); 
                }
            }

            time++;
            updateCountdown();
            
            wind += (targetWind - wind) * 0.05;
            beatIntensity *= 0.9;

            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, width, height);
            
            const theme = THEMES[currentThemeIndex];
            const gradient = ctx.createRadialGradient(width/2, height, 10, width/2, height, width);
            gradient.addColorStop(0, theme.bgGradient[0]);
            gradient.addColorStop(0.5, theme.bgGradient[1]);
            gradient.addColorStop(1, theme.bgGradient[2]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            drawAurora(ctx, width, height, time);
            
            // Update Greeting Particles with correct behavior
            if (isChristmasToday && greetingParticles.length > 0) {
                ctx.globalCompositeOperation = 'lighter';
                greetingParticles.forEach(gp => {
                    gp.update();
                    gp.draw(ctx);
                });
            }

            shootingStars.forEach(star => {
                star.update();
                star.draw(ctx);
            });

            const fireworkChance = isChristmasToday ? 0.05 : 0.02; 

            if (treeState === 'assembled' && Math.random() < fireworkChance) {
                fireworks.push(new Firework());
            }
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.update();
                fw.draw(ctx);
                if (fw.state === 'dead') fireworks.splice(i, 1);
            }

            const centerY = height * 0.55; 
            const centerX = width / 2;

            autoRotate += rotationSpeed;

            stateTimer++;
            
            if (treeState === 'assembling') {
                if(!userHasEditedText && lastTreeState !== 'assembling') {
                    instructions.innerText = "The magic is rising...";
                    instructions.style.color = "rgba(255,255,255,0.8)";
                }
                instructions.style.opacity = 1;
                let formedCount = particles.filter(p => p.state === 'formed').length;
                if (formedCount > particles.length * 0.95) {
                    treeState = 'assembled';
                    stateTimer = 0;
                    if(!userHasEditedText) {
                        instructions.innerText = isChristmasToday ? "IT'S CHRISTMAS DAY!" : "MERRY CHRISTMAS";
                        if(isChristmasToday) instructions.style.color = "#ffd700";
                    }
                    if (isChristmasToday) launchGrandFinale();
                }
            } else if (treeState === 'assembled') {
                if (stateTimer > holdDuration) {
                    treeState = 'disassembling';
                    stateTimer = 0;
                    instructions.style.opacity = 0;
                }
            } else if (treeState === 'disassembling') {
                let vanishedCount = particles.filter(p => p.opacity <= 0).length;
                if (vanishedCount > particles.length * 0.95) {
                    if (isRecordingGIF) {
                        finishGIFRecording();
                    }
                    
                    treeState = 'assembling';
                    stateTimer = 0;
                    particles.forEach(p => {
                        p.resetProperties(); 
                        p.y = height + Math.random() * 200;
                        p.x = (Math.random() - 0.5) * width;
                        p.z = (Math.random() - 0.5) * 500;
                        p.state = 'idle';
                    });
                    
                    // Reset Greeting Particles too
                    if(isChristmasToday && greetingParticles.length > 0) {
                         greetingParticles.forEach(gp => gp.reset());
                    }
                }
            }
            lastTreeState = treeState;

            ctx.globalCompositeOperation = 'lighter'; 

            particles.forEach(p => {
                let targetRx = (p.state === 'formed') ? p.treeTargetX : p.x;
                let targetRz = (p.state === 'formed') ? p.treeTargetZ : p.z;
                const cos = Math.cos(autoRotate);
                const sin = Math.sin(autoRotate);
                p._depth = targetRx * sin + targetRz * cos;
            });
            particles.sort((a, b) => b._depth - a._depth);

            if (treeState === 'assembling' || treeState === 'assembled' || treeState === 'disassembling') {
                ctx.save();
                const floorOffset = 250 * treeScale * (1 + beatIntensity * 0.01); 
                const floorScreenY = centerY + floorOffset; 
                ctx.translate(0, floorScreenY); 
                ctx.scale(1, -0.3); 
                ctx.translate(0, -floorScreenY);
                particles.forEach((p, index) => {
                    if (index % 3 === 0) {
                        // Increase opacity for reflection
                        p.draw(ctx, centerX, centerY, autoRotate, 0.4);
                    }
                });
                // No star reflection as requested
                ctx.restore();
            }

            particles.forEach(p => {
                p.update(centerX, centerY, autoRotate);
                p.draw(ctx, centerX, centerY, autoRotate);
            });
            
            starTopper.draw(ctx, centerX, centerY, autoRotate);

            ctx.globalCompositeOperation = 'source-over'; 
            snowParticles.forEach(p => {
                p.update();
                p.draw(ctx, centerX, centerY);
            });

            // Fireflies (New)
            ctx.globalCompositeOperation = 'lighter';
            fireflies.forEach(f => {
                f.update();
                f.draw(ctx);
            });

            for (let i = sparklers.length - 1; i >= 0; i--) {
                const s = sparklers[i];
                s.update();
                s.draw(ctx);
                if (s.life <= 0) sparklers.splice(i, 1);
            }

            requestAnimationFrame(animate);
        }

        // --- Interaction Handlers ---

        function handleInput(x) {
            const xNormal = (x / width) - 0.5;
            rotationSpeed = 0.005 + xNormal * 0.02;
            targetWind = xNormal * 2; 
        }

        function spawnSparkles(x, y) {
            const count = 20;
            for(let i = 0; i < count; i++) {
                sparklers.push(new Sparkler(x, y));
            }
        }
        
        function handleTapOrClick(x, y) {
            if (y < height * 0.4) {
                fireworks.push(new Firework(x, y, true));
            } else {
                spawnSparkles(x, y);
            }
        }

        window.addEventListener('dblclick', () => {
            uiLayer.classList.toggle('hidden');
        });
        window.addEventListener('touchstart', (e) => {
            if (e.target.id === 'theme-btn' || e.target.id === 'music-btn' || e.target.id === 'blizzard-btn' || e.target.id === 'gif-btn') return;
            handleDoubleTap();
            if (e.touches.length > 0) {
                handleTapOrClick(e.touches[0].clientX, e.touches[0].clientY);
                handleInput(e.touches[0].clientX); 
            }
        }, { passive: false });

        window.addEventListener('mousemove', (e) => handleInput(e.clientX));
        window.addEventListener('mousedown', (e) => {
            if (e.target.closest('.control-btn') || e.target.id === 'instructions') return;
            handleTapOrClick(e.clientX, e.clientY);
        });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                handleInput(e.touches[0].clientX);
            }
        }, { passive: true });

        window.addEventListener('deviceorientation', (e) => {
            if (e.gamma !== null) {
                let gamma = Math.max(-30, Math.min(30, e.gamma));
                const xNormal = gamma / 60; 
                rotationSpeed = 0.005 + xNormal * 0.02;
                targetWind = xNormal * 2;
            }
        });

        window.addEventListener('resize', resize);

        init();

    </script>
</body>
</html>