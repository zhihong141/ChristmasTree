<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree Particles</title>
    <!-- Import Cinzel Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205; 
            font-family: 'Cinzel', serif; /* Updated Font */
            user-select: none; 
            -webkit-user-select: none;
            touch-action: none; 
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 3px; /* Increased spacing for cinematic look */
            font-size: 0.9rem;
            transition: opacity 1s;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            z-index: 5;
            font-weight: 700;
        }
        #footer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.3);
            font-family: 'Cinzel', serif;
            font-size: 0.6rem;
            pointer-events: none;
            letter-spacing: 1px;
            text-transform: uppercase;
            z-index: 5;
        }
        #countdown {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Courier New', monospace; /* Keep timer monospaced */
            font-size: 0.9rem;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
            text-align: right;
            z-index: 5;
        }
        #countdown label {
            display: block;
            font-size: 0.5rem;
            opacity: 0.7;
            font-family: 'Cinzel', serif;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .control-btn {
            position: absolute;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.7rem;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            transition: all 0.3s;
            border-radius: 20px;
            background: rgba(0,0,0,0.2);
            z-index: 10;
            backdrop-filter: blur(2px);
            -webkit-tap-highlight-color: transparent;
            text-align: center;
            min-width: 80px;
            letter-spacing: 1px;
        }
        .control-btn:active, .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: white;
        }
        #theme-btn { top: 50px; }
        #music-btn { top: 90px; }

        @media (max-width: 600px) {
            #theme-btn {
                top: 60px; 
                right: 10px;
                font-size: 0.6rem;
                padding: 6px 12px;
                min-width: 60px;
            }
            #music-btn {
                top: 95px;
                right: 10px;
                font-size: 0.6rem;
                padding: 6px 12px;
                min-width: 60px;
            }
            #countdown {
                right: 10px;
                bottom: 10px;
            }
            #footer {
                left: 10px;
                bottom: 10px;
            }
        }
    </style>
</head>
<body>

    <div id="instructions">Tap sky for fireworks, ground for sparks!</div>
    
    <div id="theme-btn" class="control-btn">Theme: Classic</div>
    <div id="music-btn" class="control-btn">Music: Off</div>
    
    <div id="countdown">
        <label>Time to Christmas</label>
        <span id="timer-val">--:--:--:--</span>
    </div>

    <div id="footer">&copy; 2025 Designed by SEVEN.FOUR</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const instructions = document.getElementById('instructions');
        const themeBtn = document.getElementById('theme-btn');
        const musicBtn = document.getElementById('music-btn');
        const timerVal = document.getElementById('timer-val');

        let width, height;
        let particles = [];
        let snowParticles = [];
        let shootingStars = [];
        let sparklers = [];
        let fireworks = []; 
        let treeScale = 1; 
        let starTopper = null; 
        let beatIntensity = 0; 
        
        let rotationSpeed = 0.005;
        let autoRotate = 0;
        let wind = 0;
        let targetWind = 0;

        let time = 0; 
        
        let treeState = 'assembling'; 
        let stateTimer = 0;
        const HOLD_DURATION = 480; 

        const PARTICLE_COUNT = 1200; 
        const GIFT_PARTICLE_COUNT = 200; 
        const TREE_HEIGHT = 500;
        const TREE_WIDTH = 250;
        const FOCAL_LENGTH = 800;
        
        const THEMES = [
            {
                name: 'Classic',
                greens: ['#2e7d32', '#43a047', '#66bb6a', '#a5d6a7', '#1b5e20'],
                giftColors: ['#d32f2f', '#ffa000', '#1976d2'],
                bgGradient: ['#0f2027', '#05101a', '#000000'],
                ornamentStyle: 'dynamic'
            },
            {
                name: 'Frozen',
                greens: ['#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#0288d1'],
                giftColors: ['#ffffff', '#80deea', '#0097a7'],
                bgGradient: ['#1c2e4a', '#101f30', '#000000'],
                ornamentStyle: 'cyan'
            },
            {
                name: 'Midnight',
                greens: ['#7b1fa2', '#8e24aa', '#ab47bc', '#ce93d8', '#4a148c'],
                giftColors: ['#ffd700', '#eeeeee', '#6a1b9a'],
                bgGradient: ['#240b36', '#10051a', '#000000'],
                ornamentStyle: 'gold'
            }
        ];
        let currentThemeIndex = 0;

        // --- MUSIC SYSTEM ---
        const Music = {
            ctx: null,
            isPlaying: false,
            osc: null,
            gain: null,
            timer: null,
            noteIndex: 0,
            melody: [
                {n: 'E4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.5},
                {n: 'E4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.5},
                {n: 'E4', d: 0.25}, {n: 'G4', d: 0.25}, {n: 'C4', d: 0.35}, {n: 'D4', d: 0.15}, {n: 'E4', d: 1.0},
                {n: 'F4', d: 0.25}, {n: 'F4', d: 0.25}, {n: 'F4', d: 0.25}, {n: 'F4', d: 0.25},
                {n: 'F4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.25}, {n: 'E4', d: 0.125}, {n: 'E4', d: 0.125},
                {n: 'E4', d: 0.25}, {n: 'D4', d: 0.25}, {n: 'D4', d: 0.25}, {n: 'E4', d: 0.25},
                {n: 'D4', d: 0.5}, {n: 'G4', d: 0.5}
            ],
            freqs: {
                'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00
            },
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playNote: function(freq, duration) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.value = freq;
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.05); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.start(now);
                osc.stop(now + duration + 0.1);

                beatIntensity = 1.0; 
            },
            loop: function() {
                if (!this.isPlaying) return;
                const note = this.melody[this.noteIndex];
                const freq = this.freqs[note.n];
                const beatDuration = 600; 
                const noteDuration = note.d * beatDuration;
                
                this.playNote(freq, note.d * 1.5);
                
                this.noteIndex = (this.noteIndex + 1) % this.melody.length;
                this.timer = setTimeout(() => this.loop(), noteDuration);
            },
            toggle: function() {
                this.init();
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }

                this.isPlaying = !this.isPlaying;
                if (this.isPlaying) {
                    musicBtn.innerText = "Music: On";
                    this.loop();
                } else {
                    musicBtn.innerText = "Music: Off";
                    clearTimeout(this.timer);
                }
            }
        };

        class StarTopper {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = 0;
                this.y = TREE_HEIGHT / 2;
                this.z = 0;
                this.size = 12; 
                this.opacity = 0;
                this.color = '#fffbe3'; 
                this.twinkleOffset = Math.random() * 100;
            }
            update() {
                if (treeState === 'assembling' || treeState === 'assembled') {
                    if (this.opacity < 1) this.opacity += 0.01;
                } else if (treeState === 'disassembling') {
                    if (this.opacity > 0) this.opacity -= 0.04;
                }
            }
            draw(ctx, centerX, centerY, globalRotation) {
                if (this.opacity <= 0.01) return;

                // Make pulse softer (0.15 instead of 0.3)
                const beatScale = 1 + beatIntensity * 0.15;
                const scale = (FOCAL_LENGTH / (FOCAL_LENGTH + 0)) * treeScale * beatScale;
                
                const x2d = centerX; 
                const y2d = centerY - this.y * scale / beatScale; 

                const twinkle = 0.8 + 0.4 * Math.sin(time * 0.15 + this.twinkleOffset);
                
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                
                const spikes = 5;
                const outerRadius = this.size * scale * twinkle;
                const innerRadius = outerRadius / 2;
                
                ctx.save();
                ctx.translate(x2d, y2d);
                ctx.rotate(time * 0.01);
                ctx.beginPath();
                for (let i = 0; i < spikes * 2; i++) {
                    const r = (i % 2 === 0) ? outerRadius : innerRadius;
                    const a = (Math.PI / spikes) * i;
                    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
                }
                ctx.closePath();
                
                ctx.shadowBlur = 40 * scale;
                ctx.shadowColor = "rgba(255, 255, 200, 0.9)";
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 10 * scale;
                ctx.fill();

                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        class Firework {
            constructor(x, y, isClick = false) {
                this.reset(x, y, isClick);
            }
            reset(startX, startY, isClick) {
                this.particles = [];
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                if (isClick) {
                    this.state = 'exploding';
                    this.explode(startX, startY);
                } else {
                    this.x = Math.random() * width;
                    this.y = height;
                    this.targetY = height * 0.1 + Math.random() * (height * 0.4);
                    this.speed = 8 + Math.random() * 4;
                    this.state = 'launching';
                }
            }
            update() {
                if (this.state === 'launching') {
                    this.y -= this.speed;
                    this.speed *= 0.98; 
                    if(Math.random() < 0.5) {
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        ctx.fillRect(this.x + (Math.random()-0.5)*2, this.y, 2, 2);
                    }
                    if (this.y <= this.targetY || this.speed < 1) {
                        this.state = 'exploding';
                        this.explode(this.x, this.y);
                    }
                } else if (this.state === 'exploding') {
                    let aliveCount = 0;
                    this.particles.forEach(p => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.05; 
                        p.life -= 0.02;
                        if(p.life > 0) aliveCount++;
                    });
                    if (aliveCount === 0) this.state = 'dead';
                }
            }
            explode(x, y) {
                const count = 30; 
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        color: this.color
                    });
                }
            }
            draw(ctx) {
                if (this.state === 'launching') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x - 1, this.y, 3, 8);
                } else if (this.state === 'exploding') {
                    this.particles.forEach(p => {
                        if (p.life > 0) {
                            ctx.globalAlpha = p.life;
                            ctx.fillStyle = p.color;
                            ctx.fillRect(p.x, p.y, 3, 3);
                        }
                    });
                    ctx.globalAlpha = 1;
                }
            }
        }

        class Sparkler {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.decay = Math.random() * 0.03 + 0.01;
                const colors = ['#ffd700', '#ffffff', '#ff4444'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.gravity = 0.15;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += this.gravity;
                this.vx *= 0.95; 
                this.vy *= 0.95;
                this.life -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 3, 3);
                ctx.globalAlpha = 1;
            }
        }

        class ShootingStar {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height * 0.4; 
                this.length = 0;
                this.maxLength = Math.random() * 100 + 50;
                this.speed = Math.random() * 15 + 10;
                this.angle = Math.PI / 4 + (Math.random() * 0.2 - 0.1); 
                this.opacity = 0;
                this.state = 'waiting';
                this.waitTimer = Math.random() * 300 + 100;
            }
            update() {
                if (this.state === 'waiting') {
                    this.waitTimer--;
                    if (this.waitTimer <= 0) {
                        this.state = 'shooting';
                        this.opacity = 1;
                    }
                } else if (this.state === 'shooting') {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.length = Math.min(this.length + this.speed, this.maxLength);
                    this.opacity -= 0.015;
                    if (this.opacity <= 0 || this.x > width || this.y > height) {
                        this.reset();
                    }
                }
            }
            draw(ctx) {
                if (this.state !== 'shooting') return;
                const tailX = this.x - Math.cos(this.angle) * this.length;
                const tailY = this.y - Math.sin(this.angle) * this.length;
                const grad = ctx.createLinearGradient(this.x, this.y, tailX, tailY);
                grad.addColorStop(0, `rgba(255,255,255,${this.opacity})`);
                grad.addColorStop(1, `rgba(255,255,255,0)`);
                ctx.lineWidth = 2;
                ctx.strokeStyle = grad;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(tailX, tailY);
                ctx.stroke();
            }
        }

        class SnowParticle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = (Math.random() - 0.5) * width;
                this.y = -height/2 - Math.random() * height; 
                this.z = (Math.random() - 0.5) * 800;
                this.size = Math.random() * 2 + 0.5;
                this.speed = Math.random() * 2 + 1;
                this.drift = Math.random() * Math.PI * 2;
            }
            update() {
                this.y += this.speed;
                this.x += Math.sin(this.drift) * 0.5 + wind;
                this.drift += 0.02;
                if (this.y > height/2 + 200) {
                    this.reset();
                    this.x = (Math.random() - 0.5) * width - (wind * 100);
                }
            }
            draw(ctx, centerX, centerY) {
                const scale = FOCAL_LENGTH / (FOCAL_LENGTH + this.z);
                const x2d = centerX + this.x * scale;
                const y2d = centerY + this.y * scale;
                ctx.globalAlpha = 0.6 * scale;
                ctx.fillStyle = 'white';
                const s = this.size * scale;
                ctx.fillRect(x2d, y2d, s, s);
                ctx.globalAlpha = 1;
            }
        }

        class Particle {
            constructor(type) {
                this.type = type; 
                this.twinkleOffset = Math.random() * 100;
                this.resetProperties();
                this.y = height + Math.random() * 200; 
                this.x = (Math.random() - 0.5) * width;
                this.z = (Math.random() - 0.5) * 500;
            }

            resetProperties() {
                const theme = THEMES[currentThemeIndex];
                if (this.type === 'gift') {
                    const giftIndex = Math.floor(Math.random() * theme.giftColors.length);
                    this.color = theme.giftColors[giftIndex];
                    this.size = 2.5;
                    const angleOffset = (giftIndex * (Math.PI * 2 / 3)) + (Math.PI / 6);
                    const radius = 90; 
                    const centerX = Math.cos(angleOffset) * radius;
                    const centerZ = Math.sin(angleOffset) * radius;
                    const boxSize = 50;
                    this.treeTargetX = centerX + (Math.random() - 0.5) * boxSize;
                    this.treeTargetZ = centerZ + (Math.random() - 0.5) * boxSize;
                    this.treeTargetY = -250 + (Math.random() * boxSize); 
                } else {
                    let h = Math.random(); 
                    if (this.type === 'star') {
                        h = 0.99 + Math.random() * 0.01;
                        this.color = '#ffffff';
                        this.size = 2.5 + Math.random() * 2;
                    } else if (this.type === 'ornament') {
                        this.baseHue = Math.random() * 360; 
                        this.size = 3.5; 
                        this.color = null; 
                    } else {
                        this.color = theme.greens[Math.floor(Math.random() * theme.greens.length)];
                        this.size = 1 + Math.random() * 1.5;
                    }
                    const maxR = TREE_WIDTH / 2;
                    const r = (1 - h) * maxR * (0.8 + Math.random() * 0.4); 
                    const angle = Math.random() * Math.PI * 2;
                    this.treeTargetY = (h - 0.5) * TREE_HEIGHT;
                    this.treeTargetX = Math.cos(angle) * r;
                    this.treeTargetZ = Math.sin(angle) * r;
                }
                this.drift = Math.random() * Math.PI * 2;
                this.riseSpeed = 4 + Math.random() * 4;
                this.fallSpeed = 2 + Math.random() * 3;
                this.state = 'idle'; 
                this.opacity = 1;
            }

            refreshColor() {
                const theme = THEMES[currentThemeIndex];
                if (this.type === 'leaf') {
                    this.color = theme.greens[Math.floor(Math.random() * theme.greens.length)];
                } else if (this.type === 'gift') {
                    this.color = theme.giftColors[Math.floor(Math.random() * theme.giftColors.length)];
                }
            }

            update(centerX, centerY, globalRotation) {
                if (treeState === 'assembling') {
                    if (this.state !== 'formed') {
                        const distY = this.y - this.treeTargetY;
                        let currentSpeed = this.riseSpeed;
                        if (distY < 100 && distY > 0) {
                            currentSpeed = Math.max(0.5, currentSpeed * (distY / 100));
                        }
                        this.y -= currentSpeed;
                        this.x += (this.treeTargetX - this.x) * 0.1;
                        this.z += (this.treeTargetZ - this.z) * 0.1;
                        if (Math.abs(distY) <= 1.5 && Math.abs(this.x - this.treeTargetX) < 2) {
                            this.state = 'formed';
                            this.y = this.treeTargetY;
                            this.x = this.treeTargetX;
                            this.z = this.treeTargetZ;
                        }
                    } else {
                        this.drift += 0.05;
                    }
                }
                else if (treeState === 'assembled') {
                    this.drift += 0.05;
                }
                else if (treeState === 'disassembling') {
                    this.state = 'dissipating';
                    this.y += this.fallSpeed; // Fall down
                    
                    // Simple drift
                    this.x += Math.sin(this.drift) * 1.0 + wind; 
                    this.z += Math.cos(this.drift) * 1.0;
                    this.drift += 0.05;
                    
                    this.opacity -= 0.015; // Fade out as they fall
                    if (this.opacity < 0) this.opacity = 0;
                }
            }

            draw(ctx, centerX, centerY, globalRotation, alphaMult = 1) {
                let targetRx = (this.state === 'formed') ? this.treeTargetX : this.x;
                let targetRz = (this.state === 'formed') ? this.treeTargetZ : this.z;
                let ry;
                if (this.state !== 'formed') ry = this.y;
                else ry = this.treeTargetY;

                const cos = Math.cos(globalRotation);
                const sin = Math.sin(globalRotation);
                let rx = targetRx * cos - targetRz * sin;
                let rz = targetRx * sin + targetRz * cos;

                // VISUALIZER: Scale tree with beat (Softer pulse: 0.02)
                const beatScale = 1 + beatIntensity * 0.02;
                const scale = (FOCAL_LENGTH / (FOCAL_LENGTH + rz)) * treeScale * beatScale;
                
                const x2d = centerX + rx * scale;
                const y2d = centerY - ry * scale; 

                let twinkle = 1;
                if (this.type === 'ornament' || this.type === 'star') {
                    twinkle = 0.8 + 0.4 * Math.sin(time * 0.1 + this.twinkleOffset);
                }

                const alpha = Math.min(1, scale * 0.9) * this.opacity * alphaMult;
                ctx.globalAlpha = alpha;
                
                let drawColor = this.color;
                const theme = THEMES[currentThemeIndex];

                if (this.type === 'ornament') {
                    if (theme.ornamentStyle === 'dynamic') {
                        const currentHue = (this.baseHue + time * 0.5) % 360;
                        drawColor = `hsl(${currentHue}, 80%, 60%)`;
                    } else if (theme.ornamentStyle === 'cyan') {
                        drawColor = '#00e5ff';
                    } else if (theme.ornamentStyle === 'gold') {
                        drawColor = '#ffd700';
                    }
                }

                ctx.fillStyle = drawColor;
                let currentSize = this.size * scale;
                if (this.type !== 'leaf' && this.type !== 'gift') {
                     currentSize *= twinkle; 
                }

                if (this.type === 'star') {
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.1, currentSize), 0, Math.PI * 2);
                    ctx.shadowBlur = 30 * scale * twinkle;
                    ctx.shadowColor = `rgba(255, 255, 255, ${0.9 * this.opacity * alphaMult})`;
                    ctx.fill();
                    ctx.shadowBlur = 0; 
                } 
                else if (this.type === 'ornament') {
                    ctx.beginPath();
                    ctx.arc(x2d, y2d, Math.max(0.1, currentSize), 0, Math.PI * 2);
                    ctx.fill();
                } 
                else {
                    ctx.fillRect(x2d - currentSize/2, y2d - currentSize/2, currentSize, currentSize);
                }
                ctx.globalAlpha = 1;
            }
        }

        function drawAurora(ctx, width, height, time) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < 3; i++) {
                const gradient = ctx.createLinearGradient(0, 0, width, 0);
                gradient.addColorStop(0, `rgba(0, 0, 0, 0)`);
                gradient.addColorStop(0.3, `hsla(${160 + i * 20}, 80%, 30%, 0.1)`);
                gradient.addColorStop(0.5, `hsla(${260 + i * 20}, 70%, 40%, 0.15)`);
                gradient.addColorStop(0.7, `hsla(${160 + i * 20}, 80%, 30%, 0.1)`);
                gradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, height);
                for (let x = 0; x <= width; x += 50) {
                    const y = height * 0.4 + 
                              Math.sin(x * 0.005 + time * 0.02 + i) * 100 + 
                              Math.sin(x * 0.01 - time * 0.01) * 50;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.fill();
            }
            ctx.restore();
        }

        function updateCountdown() {
            const now = new Date();
            const currentYear = now.getFullYear();
            let xmas = new Date(currentYear, 11, 25);
            if (now.getTime() > xmas.getTime()) {
                xmas = new Date(currentYear + 1, 11, 25);
            }
            const diff = xmas - now;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diff % (1000 * 60)) / 1000);
            timerVal.innerText = `${days}d ${hours}h ${minutes}m ${seconds}s`;
        }

        function toggleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
            const theme = THEMES[currentThemeIndex];
            themeBtn.innerText = `Theme: ${theme.name}`;
            particles.forEach(p => p.refreshColor());
        }

        function init() {
            resize();
            createParticles();
            createSnow();
            createShootingStars();
            starTopper = new StarTopper(); 
            
            themeBtn.addEventListener('click', toggleTheme);
            themeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                e.stopPropagation(); 
                toggleTheme();
            }, { passive: false });

            musicBtn.addEventListener('click', () => Music.toggle());
            musicBtn.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                e.stopPropagation();
                Music.toggle();
            }, { passive: false });

            animate();
        }

        function createShootingStars() {
            shootingStars = [];
            for(let i=0; i<3; i++) {
                shootingStars.push(new ShootingStar());
            }
        }

        function createSnow() {
            snowParticles = [];
            for (let i = 0; i < 200; i++) {
                snowParticles.push(new SnowParticle());
            }
        }

        function createParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let type = 'leaf';
                if (i < 50) type = 'star';
                else if (i < 200) type = 'ornament';
                particles.push(new Particle(type));
            }
            for (let i = 0; i < GIFT_PARTICLE_COUNT; i++) {
                particles.push(new Particle('gift'));
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            treeScale = Math.min(1, Math.max(0.5, width / 350), Math.max(0.5, height / 650));
        }

        function animate() {
            time++;
            updateCountdown();
            
            wind += (targetWind - wind) * 0.05;
            
            beatIntensity *= 0.9;

            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, width, height);
            
            const theme = THEMES[currentThemeIndex];
            const gradient = ctx.createRadialGradient(width/2, height, 10, width/2, height, width);
            gradient.addColorStop(0, theme.bgGradient[0]);
            gradient.addColorStop(0.5, theme.bgGradient[1]);
            gradient.addColorStop(1, theme.bgGradient[2]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            drawAurora(ctx, width, height, time);

            shootingStars.forEach(star => {
                star.update();
                star.draw(ctx);
            });

            // Random fireworks during hold (keep them)
            if (treeState === 'assembled' && Math.random() < 0.02) {
                fireworks.push(new Firework());
            }
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const fw = fireworks[i];
                fw.update();
                fw.draw(ctx);
                if (fw.state === 'dead') fireworks.splice(i, 1);
            }

            const centerY = height * 0.55; 
            const centerX = width / 2;

            autoRotate += rotationSpeed;

            stateTimer++;
            if (treeState === 'assembling') {
                instructions.innerText = "The magic is rising...";
                instructions.style.opacity = 1;
                let formedCount = particles.filter(p => p.state === 'formed').length;
                if (formedCount > particles.length * 0.95) {
                    treeState = 'assembled';
                    stateTimer = 0;
                    instructions.innerText = "MERRY CHRISTMAS";
                }
            } else if (treeState === 'assembled') {
                if (stateTimer > HOLD_DURATION) {
                    treeState = 'disassembling';
                    stateTimer = 0;
                    instructions.style.opacity = 0;
                }
            } else if (treeState === 'disassembling') {
                let vanishedCount = particles.filter(p => p.opacity <= 0).length;
                if (vanishedCount > particles.length * 0.95) {
                    treeState = 'assembling';
                    stateTimer = 0;
                    particles.forEach(p => {
                        p.resetProperties(); 
                        p.y = height + Math.random() * 200;
                        p.x = (Math.random() - 0.5) * width;
                        p.z = (Math.random() - 0.5) * 500;
                        p.state = 'idle';
                    });
                }
            }

            ctx.globalCompositeOperation = 'lighter'; 

            particles.forEach(p => {
                let targetRx = (p.state === 'formed') ? p.treeTargetX : p.x;
                let targetRz = (p.state === 'formed') ? p.treeTargetZ : p.z;
                const cos = Math.cos(autoRotate);
                const sin = Math.sin(autoRotate);
                p._depth = targetRx * sin + targetRz * cos;
            });
            particles.sort((a, b) => b._depth - a._depth);

            if (treeState === 'assembling' || treeState === 'assembled' || treeState === 'disassembling') {
                ctx.save();
                // Apply beat to reflection position slightly too
                const floorOffset = 250 * treeScale * (1 + beatIntensity * 0.01); 
                const floorScreenY = centerY + floorOffset; 
                
                ctx.translate(0, floorScreenY); 
                ctx.scale(1, -0.3); 
                ctx.translate(0, -floorScreenY);
                
                particles.forEach((p, index) => {
                    if (index % 3 === 0) {
                        p.draw(ctx, centerX, centerY, autoRotate, 0.2);
                    }
                });
                
                starTopper.update();
                starTopper.draw(ctx, centerX, centerY, autoRotate);

                ctx.restore();
            }

            particles.forEach(p => {
                p.update(centerX, centerY, autoRotate);
                p.draw(ctx, centerX, centerY, autoRotate);
            });
            
            starTopper.draw(ctx, centerX, centerY, autoRotate);

            ctx.globalCompositeOperation = 'source-over'; 
            snowParticles.forEach(p => {
                p.update();
                p.draw(ctx, centerX, centerY);
            });

            ctx.globalCompositeOperation = 'lighter';
            for (let i = sparklers.length - 1; i >= 0; i--) {
                const s = sparklers[i];
                s.update();
                s.draw(ctx);
                if (s.life <= 0) {
                    sparklers.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        // --- Interaction Handlers ---

        function handleInput(x) {
            const xNormal = (x / width) - 0.5;
            rotationSpeed = 0.005 + xNormal * 0.02;
            targetWind = xNormal * 2; 
        }

        function spawnSparkles(x, y) {
            const count = 20;
            for(let i = 0; i < count; i++) {
                sparklers.push(new Sparkler(x, y));
            }
        }
        
        function handleTapOrClick(x, y) {
            if (y < height * 0.4) {
                fireworks.push(new Firework(x, y, true));
            } else {
                spawnSparkles(x, y);
            }
        }

        window.addEventListener('mousemove', (e) => handleInput(e.clientX));
        window.addEventListener('mousedown', (e) => {
            if (e.target.id === 'theme-btn' || e.target.id === 'music-btn') return;
            handleTapOrClick(e.clientX, e.clientY);
        });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                handleInput(e.touches[0].clientX);
            }
        }, { passive: true });

        window.addEventListener('touchstart', (e) => {
            if (e.target.id === 'theme-btn' || e.target.id === 'music-btn') return;
            if (e.touches.length > 0) {
                handleTapOrClick(e.touches[0].clientX, e.touches[0].clientY);
                handleInput(e.touches[0].clientX); 
            }
        }, { passive: false });

        window.addEventListener('deviceorientation', (e) => {
            if (e.gamma !== null) {
                let gamma = Math.max(-30, Math.min(30, e.gamma));
                const xNormal = gamma / 60; 
                rotationSpeed = 0.005 + xNormal * 0.02;
                targetWind = xNormal * 2;
            }
        });

        window.addEventListener('resize', resize);

        init();

    </script>
</body>
</html>